# C++ –ö–æ–Ω—Å–ø–µ–∫—Ç

## 1. –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º (Optimal Substructure)

## 2. –ó–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã, —á—Ç–æ–±—ã –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Å—å –∫–æ–¥.

## 3. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

### –°–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ (Linked List) –∏ –º–∞—Å—Å–∏–≤ (Array)

- –ß—Ç–µ–Ω–∏–µ: `O(1)`, `O(n)`
- –ó–∞–ø–∏—Å—å: `O(1)`, `O(n)`
- –í—Å—Ç–∞–≤–∫–∞: `O(n)`, `O(1)`
- –£–¥–∞–ª–µ–Ω–∏–µ: `O(n)`, `O(1)`
- –ñ—É—Ä–Ω–∞–ª (log) –∏ –æ—á–µ—Ä–µ–¥—å (queue)

### –°—Ç–µ–∫ (Stack) –∏ –û—á–µ—Ä–µ–¥—å (Queue)

- **Stack**: –ü–µ—Ä–≤—ã–º –ø—Ä–∏—à—ë–ª - –ø–æ—Å–ª–µ–¥–Ω–∏–º –≤—ã—à–µ–ª (**LIFO**)
- **Queue**: –ü–µ—Ä–≤—ã–º –ø—Ä–∏—à—ë–ª - –ø–µ—Ä–≤—ã–º –≤—ã—à–µ–ª (**FIFO**)

## 4. –ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ (Overloading) –∏ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (Overriding)

### –ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ (Overloaded)

```cpp
void myFunction(int x);
void myFunction(double y);
```

–ú–µ—Ç–æ–¥—ã —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏, –Ω–æ —Ä–∞–∑–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.

### –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (Overriding)

```cpp
class Base {
public:
    virtual void myFunction() { }
};

class Derived : public Base {
public:
    void myFunction() override { }
};
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `override` –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–≤–µ–¥–µ–Ω–∏—è –º–µ—Ç–æ–¥–∞ –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞.

## 5. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã STL

### `set` (—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ)

```cpp
#include <set>
```

- –î–æ–±–∞–≤–ª—è–µ—Ç **—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ** —ç–ª–µ–º–µ–Ω—Ç—ã
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ **—Å–æ—Ä—Ç–∏—Ä—É–µ—Ç**

### `unordered_set` (–Ω–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ)

```cpp
#include <unordered_set>
```

- –î–æ–±–∞–≤–ª—è–µ—Ç **—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ** —ç–ª–µ–º–µ–Ω—Ç—ã
- **–ù–µ —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç**

### `map` (–æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ)

```cpp
#include <map>
map<string, int> nameToAge;
nameToAge["Alice"] = 30;
nameToAge["Bob"] = 25;
nameToAge["Alice"] = 32; // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
```

## 6. –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ

```cpp
int stringToNumber(const string &digits) {
    int number = 0;
    for (char digit : digits) {
        number = number * 10 + (digit - '0'); // "123" -> 123
    }
    return number;
}
```

## 7. –ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–æ–∫–∞–º –∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã

```cpp
for (char i : copy) {
    if (duplicates.count(i)) {
        result += types[1];
    } else {
        result += types[0];
    }
}
```

### –ò—Ç–µ—Ä–∞—Ü–∏—è –æ—Ç –Ω–∞—á–∞–ª–∞

```cpp
for (const string &key1 : realKeys) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å –Ω–∞—á–∞–ª–∞
}
```

### –ò—Ç–µ—Ä–∞—Ü–∏—è —Å –∫–æ–Ω—Ü–∞

```cpp
for (auto it = copy.rbegin(); it != copy.rend(); ++it) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å –∫–æ–Ω—Ü–∞
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ `set`

```cpp
if (uniqChars.find(c) == uniqChars.end()) {
    if (result.find(key1) == result.end()) {
        // –ï—Å–ª–∏ –∫–ª—é—á –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –¥–æ–±–∞–≤–∏—Ç—å –ø—É—Å—Ç–æ–π –≤–µ–∫—Ç–æ—Ä
    }
}
```

## 8. –†–∞–∑–±–∏–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫

### –†–∞–∑–±–∏–µ–Ω–∏–µ –ø–æ –ø—Ä–æ–±–µ–ª–∞–º —Å `getline`

```cpp
#include <sstream>
string line;
getline(cin, line);
stringstream ss(line);
string type, transaction, element;
ss >> type >> transaction >> element;
```

### –†–∞–∑–±–∏–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ –≤–µ–∫—Ç–æ—Ä —Å–ª–æ–≤

```cpp
istringstream iss(command);
vector<string> realCommand;
string word;
while (iss >> word) {
    realCommand.push_back(word);
}
```

## 9. –•—ç—à-—Ç–∞–±–ª–∏—Ü—ã

- –ï—Å–ª–∏ –∫–ª—é—á —Ç–∏–ø–∞ `int`, –≤—Å—Ç–∞–≤–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –∑–∞ `O(1)`.

## 10. –ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã `MapNote`

```cpp
struct MapNote {
    int hash;
    string value;
    int count;
};
```

## 11. –û–±—É—á–µ–Ω–∏–µ —Å –ø–æ–¥–∫—Ä–µ–ø–ª–µ–Ω–∏–µ–º (Reinforcement Learning)

- **Agent** (–ê–≥–µ–Ω—Ç)
- **Reward Function** (–§—É–Ω–∫—Ü–∏—è –Ω–∞–≥—Ä–∞–¥—ã):
  ```cpp
  double reward(State s, Action a);
  ```
- **Action Policy** (–ü–æ–ª–∏—Ç–∏–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π):
  ```cpp
  Action policy(Observation o);
  ```

## 12. –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ, —Ä–µ—Å—É—Ä—Å–Ω—ã–µ –∏ —ç–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –±—é–¥–∂–µ—Ç—ã

- **–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±—é–¥–∂–µ—Ç** ‚Üí 500
- **–†–µ—Å—É—Ä—Å–Ω—ã–π –±—é–¥–∂–µ—Ç** ‚Üí 10
- **–≠–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –±—é–¥–∂–µ—Ç** ‚Üí 50
- **–û–ø—Ü–∏–∏** ‚Üí 4

------------------------

## Aggregation and Composition

### Key Concepts

- **Aggregating object** (owner) - an object that contains another object.
- **Aggregating class** - a class that contains another object.
- **Aggregated object** (subordinate) - an object contained within another object.
- **Aggregated class** - the class of the subordinate object.

### Differences Between Aggregation and Composition

- **Composition** - when one object (1) depends on another (2). Example: `Student` and `Name`, where `Name` depends on
  `Student`.
- **Aggregation** - when objects can exist independently. Example: `Address` and `Student`, where `Address` does not
  depend on `Student`.

---

## Java Learning Plan

1. **Java Basics**: variables, operators, primitive types.
2. **Arrays**: one-dimensional and multi-dimensional, `Arrays` class.
3. **OOP Basics**: introduction, principles, packages, var-arg methods, overloading, overriding.
4. **Classes and Interfaces**: `Object`, `Enum`, nested classes, generics, abstract classes.
5. **Exception Handling**: exceptions and their handling.
6. **Working with Strings**: `String`, `StringBuilder`, `StringBuffer`, text blocks.
7. **Collections**: `List`, `Deque`, `Set`, `Map`, `Collections` class.
8. **Functional Programming in Java 8**: lambda expressions, functional interfaces, method references.
9. **Collectors in Java 8**.
10. **Java IO**: working with console, `Scanner`, `Formatter`, input/output streams.
11. **File I/O**: reading/writing files, streams.

üîó [Full Java roadmap](https://github.com/borymskyi/roadmap-java-sng?tab=readme-ov-file#java-core)

---

# 18.03.2025

## Java Editions

1. **Java SE (Standard Edition)** - standard desktop applications.
2. **Java EE (Enterprise Edition)** - enterprise applications.
3. **Java ME (Micro Edition)** - mobile applications.

### Core Java Components

- **javac** - compiler (translates source code into bytecode).
- **JVM (Java Virtual Machine)** - executes bytecode.
- **JRE (Java Runtime Environment)** - JVM + libraries.
- **JDK (Java Development Kit)** - JRE + development tools.
- **IDE (Integrated Development Environment)**: Eclipse, IntelliJ IDEA, NetBeans.

Execution process:

```plaintext
Text (Hello, World!) -> Source Code (HelloWorld.java) -> Bytecode (HelloWorld.class) -> Machine Code (HelloWorld.exe)
```

---

## Lesson 4: Classes and Objects

### Example Code:

```java
public class Practice {
    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = car1; // Two references to the same object

        System.out.println(car1.color);
        System.out.println(car1.maxSpeed);
        System.out.println("-----------------");
        System.out.println(car2.color);
        System.out.println(car2.maxSpeed);
    }

    static class Car {
        String color = "red";
        int maxSpeed = 100;
    }
}
```

---

# 20.03.2025

## Spring App

### `pom.xml`

```xml

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>1.20.6</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### `application.properties` Configuration

1. SQL connection.
2. Hibernate query logging.
3. Admin password.

### Spring App Architecture

#### Road 1 (Classic Structure):

1. `model` ‚Üí `UserEntity` (database entity).
2. `dto` ‚Üí `User` (data transfer object).
3. `controller` ‚Üí `UserController` (`@RestController`, API methods).
4. `service` ‚Üí `UserService` (`@Service`, business logic).
5. `repository` ‚Üí `UserRepository` (`JpaRepository<UserEntity, UUID>`).

#### Road 2 (Implementing createUser):

```java
public List<User> getAllUsers() {
    return userRepository.findAll().stream()
            .map(userEntity -> User.builder()
                    .uuid(userEntity.getUuid())
                    .username(userEntity.getUsername())
                    .password(userEntity.getPassword())
                    .name(userEntity.getName())
                    .surname(userEntity.getSurname())
                    .balance(userEntity.getBalance())
                    .userRole(userEntity.getUserRole())
                    .createdAt(userEntity.getCreatedAt())
                    .build())
            .toList();
}
```

Additional:

- `application.properties`: `spring.jpa.hibernate.ddl-auto=update` (automatic table creation).
- `compose.yml`: `ports` (database connection).
- `scripts/init.sql`: database initialization.

---

# 21.03.2025

## Codewars: BattleShip Task (Maps)

### Useful `Map` Methods:

```java
Map<String, Integer> map = new HashMap<>(); // Stored in heap
Map<String, Integer> map = new LinkedHashMap<>(); // Maintains order
Map<String, Integer> map = new TreeMap<>(); // Sorted
map.put("Alice", 1);
map.put("Bob", 2);
map.put("Charlie", 3);
map.get("Alice"); // –±–µ—Ä–µ—Ç —á—Ç–æ –≤–Ω—É—Ç—Ä–∏ Alice
map.containsKey("Alice"); // true
map.remove("Alice"); // remove
map.keySet(); // all keys
map.values(); // all values
map.getOrDefault("Alice", 0); // 1
```

### Using `Set`

```java
Set<String> set = new HashSet<>(); // Stored in heap
Set<String> set = new LinkedHashSet<>(); // Maintains order
Set<String> set = new TreeSet<>(); // Sorted
```

## Spring Boot

1. `scripts/init.sql` - database initialization.
2. `application.properties` - SQL connection, Hibernate logging.
3. `config/SecurityConfig` - security configuration (to send requests to `/api` without authentication).
   It all comes down to creating roles in Spring Security.
4. send a POST request to `http://localhost:8080/api/users` with JSON body:

```json
{
  "username": "wasja8986",
  "password": "123456789",
  "name": "Wasja",
  "surname": "Pupkin",
  "balance": "125.3"
}
```

5. get all users with a GET request to `http://localhost:8080/api/users`.
6. write tests
7. check test separately
8. check fully `mvn package`

# 22.03.2025

## 1. Constructors, 2. Methods, 3. Parameters, 4. Arguments, 5. Overloading methods 6. Overloading constructors 7. Packages

void sum (int a, int b) - parameters
sum (1, 2) - arguments

### `@Overloading` methods

different parameters and that allows us to use the same method name

```java
    public static void sum(int a, int b) {
    System.out.println(a + b);
}

public static void sum(int a, int b, int c) {
    System.out.println(a + b + c);
}
```

### `@Overloading` constructors

firstly write the long constructor and then write the short constructor by calling the long constructor

```java
    public User(String username, String password, String name, String surname, double balance) {
    this.username = username;
    this.password = password;
    this.name = name;
    this.surname = surname;
    this.balance = balance;
}

public User(String name, String surname) {
    this(null, null, name, surname, 0.0);
}
```

### Access Modifiers `public`, `protected`, `default`, `private`

1. `public` - accessible from anywhere.
2. `protected` - accessible within the same package and subclasses.
3. `default` - accessible within the same package.
4. `private` - accessible within the same class.

# 23.03.25

## Spring Boot

1. Inverson of Control (IoC) - The principle of IoC is to invert the control of the flow of the program. Instead of the
   programmer controlling the flow of the program, the framework controls it.
2. Application Context - The Application Context is the central interface within a Spring application for providing
   configuration information to the application.
3. Dependency Injection - (–í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π) —ç—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –≤–Ω–µ—à–Ω–µ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–º—É
   –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É.
    1. Example without DI:
    ```java
    class Engine {
    public void start() {
        System.out.println("–î–≤–∏–≥–∞—Ç–µ–ª—å –∑–∞–ø—É—â–µ–Ω!");
    }
 
    class Car {
    private Engine engine = new Engine(); // class Car creates an instance of Engine

    public void drive() {
        engine.start();
        System.out.println("–ú–∞—à–∏–Ω–∞ –ø–æ–µ—Ö–∞–ª–∞!");
    }


    public class Main {
        public static void main(String[] args) {
        Car car = new Car();
        car.drive();
        }
    }
    }
    }
    ```
    2. Example with DI:
    ```java
    interface Engine {
    void start();
    }

    class PetrolEngine implements Engine {
        @Override
    public void start() {
        System.out.println("–ë–µ–Ω–∑–∏–Ω–æ–≤—ã–π –¥–≤–∏–≥–∞—Ç–µ–ª—å –∑–∞–ø—É—â–µ–Ω!");
    }
    }

    class ElectricEngine implements Engine {
        @Override
        public void start() {
            System.out.println("–≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–π –¥–≤–∏–≥–∞—Ç–µ–ª—å –∑–∞–ø—É—â–µ–Ω!");
        }
    }

    class Car {
        private Engine engine;

        public Car(Engine engine) { // Engine –≤–Ω–µ–¥—Ä—è–µ—Ç—Å—è –∏–∑–≤–Ω–µ
            this.engine = engine;
        }

        public void drive() {
            engine.start();
            System.out.println("–ú–∞—à–∏–Ω–∞ –ø–æ–µ—Ö–∞–ª–∞!");
        }
    }

    public class Main {
        public static void main(String[] args) {
            Engine engine = new PetrolEngine(); // –í—ã–±–æ—Ä –¥–≤–∏–≥–∞—Ç–µ–ª—è –∏–∑–≤–Ω–µ
            Car car = new Car(engine);
            car.drive();

            Engine electricEngine = new ElectricEngine();
            Car electricCar = new Car(electricEngine);
            electricCar.drive();
        }
    }

4. Dependency Injection:
    1. Constructor Injection - –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä.
        1. Example:
       ```java
         public class UserService {
             private final UserRepository userRepository;
 
             @Autowired
             public UserService(UserRepository userRepository) {
                 this.userRepository = userRepository;
             }
 
             
         }
         ``` 
    2. Setter Injection - –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ —Å–µ—Ç—Ç–µ—Ä.
        1. Example:
       ```java
         public class UserService {
             private UserRepository userRepository;
 
             public void setUserRepository(UserRepository userRepository) {
                 this.userRepository = userRepository;
             }
         }
         ```
    3. Field Injection - –≤–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ –ø–æ–ª–µ.
        1. Example:
       ```java
         public class UserService {
             @Autowired
             private UserRepository userRepository;
         }
         ```

5. After integration `UserService` to Spring container then `UserService` also becomes a `@Bean` and we can use it in
   other classes.

## 24.03.25

### Spring Boot @Qualifier, @Primary, @Lazy

1. `@Qualifier` - to take a specific bean when there are multiple beans of the same type. 
    1. Example:
   ```java
    @Autowired
    @Qualifier("petrolEngine")
    private Engine engine;
   ```
2. `@Primary` - to mark a bean with higher priority when there are multiple beans of the same type.
    1. Example:
   ```java
    @Bean
    @Primary
    public Engine petrolEngine() {
        return new PetrolEngine();
    }
   ```
    There's a problem with circular dependencies when two classes depend on each other. To solve this problem, we can do
1. Use `setter injection` instead of constructor injection.
    example:
   ```java
    public class ClassA {
        private ClassB b;
 
        @Autowired
        public void setB(ClassB b) {
            this.b = b;
        }
    }
   ```
2. User `@Lazy` annotation on one of the classes to create a proxy object and inject it when needed.
    example:
   ```java
    @Component
    public class ClassA {
        private ClassB b;
 
        @Autowired
        public ClassA(@Lazy ClassB b) {
            this.b = b;
        }
    }
   ```
`@Lazy` - to solve `circular dependencies` (`ClassA` depends on `ClassB` and `ClassB` depends on `ClassA`).
It tells Spring to create a proxy object and inject it when needed.

# 25.03.25
## Spring Boot @Scope, @Singleton, @Prototype. 
1. `@Scope("singleton")` - beans are created once and shared across the application.
   1. same links if we check task1 and task2
2. `@Scope("prototype")` - beans are created each time they are requested.
   2. different links if we check task1 and task2

# 27.03.25
## Bean Lifecycle @PostConstruct, @PreDestroy
1. `@PostConstruct` - method is called after the bean is created and dependencies are injected.
2. `@PreDestroy` - method is called before the bean is destroyed 
   2. `@Scope("singleton")` - in application context, `@PreDestroy` is called automatically
   2. `@Scope("prototype")` - in not application context, `@PreDestroy` we should call manually
3. 

1. –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
2. –°—Ç–∞—Ä—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
3. –°–æ–∑–¥–∞–Ω–∏–µ –±–∏–Ω–æ–≤
4. –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
5. –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ init 
6. –±–∏–Ω –≥–æ—Ç–æ–≤
7. –†–ê–ë–û–¢–ê –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
8. –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ destroy
9. –ó–∞–∫—Ä—ã—Ç–∏–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞

## Properties 
1. We use different properties files for different environments.
   1. for example: `application-dev.properties`, `application-test.properties`, `application-prod.properties`
2. In properties files we use _**Spring Expression Language**_ (SpEL) to inject values.
   2. Example:
   ```java
    import org.springframework.beans.factory.annotation.Value;@Value("${app.name}") // for primitive types
     
    @Value("${task.name}")
    private String name;

    @Value("${task.duration}")
    private Long duration;

    @Value("#{'${list.values}'.split(',')}")
    private List<Integer> values;

    @Value("#{'${set.values}'.split(',')}")
    private List<String> setValues;

    @Value("#{'${map.values}'.split(',')}")
    private Map<String, Integer> mapValues;
    
    // in properties file shoudl be
    task.name= "main-task"
    task.duration= 120
    
    list.values= 123,456,789
    set.values= abc,def,ghi
    map.values= {key1: 200,key2: 300}
   ```
# 28.03.25
## `final` and `static` keywords
1. `final` - constant value, cannot be changed.
2. `static` - belongs to the class, not to the object. (for example to count how many objects were created)
    2. We can call `static` methods without creating an object.
    2. We can call `static` methods from another class
    3. We can't use `non-static` variables and methods in `static` methods
    4. We can using class name to call `static` methods
3. If variable is `static` and `final` then it should be initialized in the class, example:
```java
public class User {
    private static final String DEFAULT_NAME = "John Doe";
    private static final int DEFAULT_AGE = 18;
}
```

# 29.03.25
## Spring Boot, Spring AOP
1. `@Aspect` - to mark a class as an aspect.
2. `@Before` - to mark a method as a before advice.
3. `@After` - to mark a method as an after advice.

# 19.04.25
## Inheritance 
1. `this` - in constructor to call another constructor from current class
   1. this(1, 2) - calls constructor with 1 and 2 parameters
2. `super` - in constructor to call constructor from parent class
   1. super(1, 2) - calls constructor with 1 and 2 parameters from parent class

# 21.04.25
## Inheritance chain
1. `Object` -> `Parent` -> `Child`

## Access Modifiers
`private` - only in the same class
`protected` - in the same package and subclasses
`default` - in the same package
`public` - everywhere

# Polymorphism –†–∞–Ω–Ω–µ–µ –∏ –ü–æ–∑–¥–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –≤ Java

## –†–∞–Ω–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (Early Binding / Static Binding)

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:** –ü—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç **–Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏**. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç, –∫–∞–∫–æ–π –∏–º–µ–Ω–Ω–æ –∫–æ–¥ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω, –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ **—Ç–∏–ø–µ —Å—Å—ã–ª–∫–∏**. –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ –ø–æ–ª—è–º, `static`, `final` –∏ `private` –º–µ—Ç–æ–¥–∞–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –ª–∏–±–æ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω–æ, –ª–∏–±–æ –∏—Ö –¥–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.

**–ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞ (–ø–æ–ª—è, static –∏ final –º–µ—Ç–æ–¥—ã):**

```java
// --- –ö–ª–∞—Å—Å—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–Ω–Ω–µ–≥–æ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è ---
class ParentEarly {
    // –ü–æ–ª–µ - —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ —Ç–∏–ø—É —Å—Å—ã–ª–∫–∏
    String type = "Parent";

    // Static –º–µ—Ç–æ–¥ - —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –ø–æ —Ç–∏–ø—É —Å—Å—ã–ª–∫–∏
    static void printStatic() {
        System.out.println("Parent Static Method");
    }

    // Final –º–µ—Ç–æ–¥ - –Ω–µ–ª—å–∑—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–∞–Ω–Ω–µ–µ
    final void printFinal() {
        System.out.println("Parent Final Method");
    }

    // Private –º–µ—Ç–æ–¥ - –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –∑–¥–µ—Å—å, —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–∞–Ω–Ω–µ–µ
    private void printPrivate() {
         System.out.println("Parent Private Method");
    }

    // –î–ª—è –ø—Ä–∏–º–µ—Ä–∞ –≤—ã–∑–æ–≤–∞ private –º–µ—Ç–æ–¥–∞
    public void callPrivateFromParent() {
        printPrivate();
    }
}

class ChildEarly extends ParentEarly {
    // –°–∫—Ä—ã–≤–∞–µ—Ç –ø–æ–ª–µ 'type' –∏–∑ ParentEarly (–Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç!)
    String type = "Child";

    // –°–∫—Ä—ã–≤–∞–µ—Ç static –º–µ—Ç–æ–¥ –∏–∑ ParentEarly (–Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç!)
    static void printStatic() {
        System.out.println("Child Static Method");
    }

    // –ù–µ–ª—å–∑—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å printFinal() –∏ printPrivate()
}

// --- –ö–ª–∞—Å—Å –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã–∑–æ–≤–æ–≤ ---
class MainEarlyBinding {
    public static void main(String[] args) {
        ParentEarly parentRefToParent = new ParentEarly(); // –°—Å—ã–ª–∫–∞ ParentEarly -> –û–±—ä–µ–∫—Ç ParentEarly
        ParentEarly parentRefToChild = new ChildEarly();   // –°—Å—ã–ª–∫–∞ ParentEarly -> –û–±—ä–µ–∫—Ç ChildEarly (–ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º)
        ChildEarly childRefToChild = new ChildEarly();     // –°—Å—ã–ª–∫–∞ ChildEarly -> –û–±—ä–µ–∫—Ç ChildEarly

        System.out.println("--- –†–∞–Ω–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (–ø–æ–ª—è) ---");
        // –î–æ—Å—Ç—É–ø –∫ –ø–æ–ª—è–º –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–∏–ø–æ–º —Å—Å—ã–ª–∫–∏ (–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º)
        System.out.println("parentRefToParent.type: " + parentRefToParent.type); // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent
        System.out.println("parentRefToChild.type: " + parentRefToChild.type);   // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent (–ø–æ —Ç–∏–ø—É —Å—Å—ã–ª–∫–∏!)
        System.out.println("childRefToChild.type: " + childRefToChild.type);     // –û–∂–∏–¥–∞–µ—Ç—Å—è: Child

        System.out.println("\n--- –†–∞–Ω–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (static –º–µ—Ç–æ–¥—ã) ---");
        // –í—ã–∑–æ–≤ static –º–µ—Ç–æ–¥–æ–≤ —á–µ—Ä–µ–∑ —Å—Å—ã–ª–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–∏–ø–æ–º —Å—Å—ã–ª–∫–∏ (–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º)
        parentRefToParent.printStatic(); // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Static Method
        parentRefToChild.printStatic();   // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Static Method (–ø–æ —Ç–∏–ø—É —Å—Å—ã–ª–∫–∏!)
        childRefToChild.printStatic();     // –û–∂–∏–¥–∞–µ—Ç—Å—è: Child Static Method
        // (–ü—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —Å–ø–æ—Å–æ–± –≤—ã–∑–æ–≤–∞ static: ParentEarly.printStatic(); ChildEarly.printStatic();)

        System.out.println("\n--- –†–∞–Ω–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (final –º–µ—Ç–æ–¥—ã) ---");
        // –í—ã–∑–æ–≤ final –º–µ—Ç–æ–¥–æ–≤ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–∏–ø–æ–º —Å—Å—ã–ª–∫–∏ (–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º), —Ç.–∫. –Ω–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
        parentRefToParent.printFinal(); // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Final Method
        parentRefToChild.printFinal();   // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Final Method
        childRefToChild.printFinal();     // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Final Method

        System.out.println("\n--- –†–∞–Ω–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (private –º–µ—Ç–æ–¥—ã) ---");
        // Private –º–µ—Ç–æ–¥—ã –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ —Å–≤–æ–µ–≥–æ –∫–ª–∞—Å—Å–∞.
        // –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –≤–Ω—É—Ç—Ä–∏ –∫–ª–∞—Å—Å–∞ ParentEarly.
        parentRefToParent.callPrivateFromParent(); // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Private Method
        // parentRefToChild.printPrivate(); // –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ - private –º–µ—Ç–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        // childRefToChild.printPrivate();  // –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ - private –º–µ—Ç–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
    }
}
```

## –ü–æ–∑–¥–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (Late Binding / Dynamic Binding)
**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:** –ü—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç **–Ω–∞ —ç—Ç–∞–ø–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è**. –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –∑–Ω–∞–µ—Ç, –∫–∞–∫–æ–π –∏–º–µ–Ω–Ω–æ –∫–æ–¥ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω, –ø–æ–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è. –ü—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ `virtual` –∏ `override` –º–µ—Ç–æ–¥–∞–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ –ø–æ–¥–∫–ª–∞—Å—Å–∞—Ö.
**–ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞ (–º–µ—Ç–æ–¥—ã):**

```java
// --- –ö–ª–∞—Å—Å—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–∑–¥–Ω–µ–≥–æ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è ---
class ParentLate {
    // –ú–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ –ø–æ–¥–∫–ª–∞—Å—Å–µ
    void print() {
        System.out.println("Parent Method");
    }
}
class ChildLate extends ParentLate {
    // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ –∏–∑ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –∫–ª–∞—Å—Å–∞
    @Override
    void print() {
        System.out.println("Child Method");
    }
}
// --- –ö–ª–∞—Å—Å –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã–∑–æ–≤–æ–≤ ---
class MainLateBinding {
    public static void main(String[] args) {
        ParentLate parentRefToParent = new ParentLate(); // –°—Å—ã–ª–∫–∞ ParentLate -> –û–±—ä–µ–∫—Ç ParentLate
        ParentLate parentRefToChild = new ChildLate();   // –°—Å—ã–ª–∫–∞ ParentLate -> –û–±—ä–µ–∫—Ç ChildLate (–ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º)
        ChildLate childRefToChild = new ChildLate();     // –°—Å—ã–ª–∫–∞ ChildLate -> –û–±—ä–µ–∫—Ç ChildLate

        System.out.println("--- –ü–æ–∑–¥–Ω–µ–µ —Å–≤—è–∑—ã–≤–∞–Ω–∏–µ (–º–µ—Ç–æ–¥—ã) ---");
        // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–æ–≤ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ç–∏–ø–æ–º –æ–±—ä–µ–∫—Ç–∞ (–Ω–∞ —ç—Ç–∞–ø–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è)
        parentRefToParent.print(); // –û–∂–∏–¥–∞–µ—Ç—Å—è: Parent Method
        parentRefToChild.print();   // –û–∂–∏–¥–∞–µ—Ç—Å—è: Child Method (–ø–æ —Ç–∏–ø—É –æ–±—ä–µ–∫—Ç–∞!)
        childRefToChild.print();     // –û–∂–∏–¥–∞–µ—Ç—Å—è: Child Method
    }
}
```

## The keyword `instanceof`
**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:** –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–±—ä–µ–∫—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –∫–ª–∞—Å—Å–∞ –∏–ª–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç `true` –∏–ª–∏ `false`.
**–ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞:**

```java
// --- –ö–ª–∞—Å—Å—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ instanceof ---
class ParentInstanceOf {
    void print() {
        System.out.println("Parent Method");
    }
}
class ChildInstanceOf extends ParentInstanceOf {
    @Override
    void print() {
        System.out.println("Child Method");
    }
}
// --- –ö–ª–∞—Å—Å –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≤—ã–∑–æ–≤–æ–≤ ---
class MainInstanceOf {
    public static void main(String[] args) {
        ParentInstanceOf parent = new ParentInstanceOf();
        ChildInstanceOf child = new ChildInstanceOf();

        System.out.println("--- instanceof ---");
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –æ–±—ä–µ–∫—Ç–∞
        System.out.println("parent instanceof ParentInstanceOf: " + (parent instanceof ParentInstanceOf)); // true
        System.out.println("child instanceof ChildInstanceOf: " + (child instanceof ChildInstanceOf)); // true
        System.out.println("child instanceof ParentInstanceOf: " + (child instanceof ParentInstanceOf)); // true
        System.out.println("parent instanceof ChildInstanceOf: " + (parent instanceof ChildInstanceOf)); // false
    }
}
```

# 22.04.25
## Methods `equals`, `hashCode`, `toString`
1. `equals` - —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É.
2. `hashCode` - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ö—ç—à-–∫–æ–¥ –æ–±—ä–µ–∫—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∫–æ–ª–ª–µ–∫—Ü–∏—è—Ö.
3. `toString` - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞.

–î–∞ `hashCode` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤.
–ê –µ—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Ç–æ:
–ù–æ —ç—Ç–æ –æ—á–µ–Ω—å –ø–ª–æ—Ö–∞—è –∏–¥–µ—è, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∞ —É–±–∏–≤–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å 
HashMap, HashSet –∏ –¥—Ä—É–≥–∏—Ö —Ö—ç—à-–∫–æ–ª–ª–µ–∫—Ü–∏–π. 
–í—Å–µ –æ–±—ä–µ–∫—Ç—ã –ø–æ–ø–∞–¥—É—Ç –≤ –æ–¥–Ω—É –∫–æ—Ä–∑–∏–Ω—É, –∏ –ø–æ–∏—Å–∫/–≤—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ —Å—Ç–∞–Ω—É—Ç –º–µ–¥–ª–µ–Ω–Ω—ã–º–∏ `(O(n)` –≤–º–µ—Å—Ç–æ `O(1))`.

## `@Override` annotation
1. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–µ—Ç–æ–¥–æ–≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ –∫–ª–∞—Å—Å–∞.