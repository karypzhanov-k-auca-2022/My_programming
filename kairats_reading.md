# C++ –ö–æ–Ω—Å–ø–µ–∫—Ç

## 1. –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–¥–ø—Ä–æ–≥—Ä–∞–º–º (Optimal Substructure)

## 2. –ó–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã, —á—Ç–æ–±—ã –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Å—å –∫–æ–¥.

## 3. –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
### –°–≤—è–∑–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ (Linked List) –∏ –º–∞—Å—Å–∏–≤ (Array)
- –ß—Ç–µ–Ω–∏–µ: `O(1)`, `O(n)`
- –ó–∞–ø–∏—Å—å: `O(1)`, `O(n)`
- –í—Å—Ç–∞–≤–∫–∞: `O(n)`, `O(1)`
- –£–¥–∞–ª–µ–Ω–∏–µ: `O(n)`, `O(1)`
- –ñ—É—Ä–Ω–∞–ª (log) –∏ –æ—á–µ—Ä–µ–¥—å (queue)

### –°—Ç–µ–∫ (Stack) –∏ –û—á–µ—Ä–µ–¥—å (Queue)
- **Stack**: –ü–µ—Ä–≤—ã–º –ø—Ä–∏—à—ë–ª - –ø–æ—Å–ª–µ–¥–Ω–∏–º –≤—ã—à–µ–ª (**LIFO**)
- **Queue**: –ü–µ—Ä–≤—ã–º –ø—Ä–∏—à—ë–ª - –ø–µ—Ä–≤—ã–º –≤—ã—à–µ–ª (**FIFO**)

## 4. –ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ (Overloading) –∏ –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (Overriding)

### –ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ (Overloaded)
```cpp
void myFunction(int x);
void myFunction(double y);
```
–ú–µ—Ç–æ–¥—ã —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∏–º–µ–Ω–∞–º–∏, –Ω–æ —Ä–∞–∑–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.

### –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ (Overriding)
```cpp
class Base {
public:
    virtual void myFunction() { }
};

class Derived : public Base {
public:
    void myFunction() override { }
};
```
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `override` –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–≤–µ–¥–µ–Ω–∏—è –º–µ—Ç–æ–¥–∞ –±–∞–∑–æ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞.

## 5. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã STL

### `set` (—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ)
```cpp
#include <set>
```
- –î–æ–±–∞–≤–ª—è–µ—Ç **—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ** —ç–ª–µ–º–µ–Ω—Ç—ã
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ **—Å–æ—Ä—Ç–∏—Ä—É–µ—Ç**

### `unordered_set` (–Ω–µ—É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ)
```cpp
#include <unordered_set>
```
- –î–æ–±–∞–≤–ª—è–µ—Ç **—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ** —ç–ª–µ–º–µ–Ω—Ç—ã
- **–ù–µ —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç**

### `map` (–æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ)
```cpp
#include <map>
map<string, int> nameToAge;
nameToAge["Alice"] = 30;
nameToAge["Bob"] = 25;
nameToAge["Alice"] = 32; // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
```

## 6. –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –≤ —á–∏—Å–ª–æ
```cpp
int stringToNumber(const string &digits) {
    int number = 0;
    for (char digit : digits) {
        number = number * 10 + (digit - '0'); // "123" -> 123
    }
    return number;
}
```

## 7. –ò—Ç–µ—Ä–∞—Ü–∏—è –ø–æ —Å—Ç—Ä–æ–∫–∞–º –∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞–º

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
```cpp
for (char i : copy) {
    if (duplicates.count(i)) {
        result += types[1];
    } else {
        result += types[0];
    }
}
```

### –ò—Ç–µ—Ä–∞—Ü–∏—è –æ—Ç –Ω–∞—á–∞–ª–∞
```cpp
for (const string &key1 : realKeys) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å –Ω–∞—á–∞–ª–∞
}
```

### –ò—Ç–µ—Ä–∞—Ü–∏—è —Å –∫–æ–Ω—Ü–∞
```cpp
for (auto it = copy.rbegin(); it != copy.rend(); ++it) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å –∫–æ–Ω—Ü–∞
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ `set`
```cpp
if (uniqChars.find(c) == uniqChars.end()) {
    if (result.find(key1) == result.end()) {
        // –ï—Å–ª–∏ –∫–ª—é—á –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –¥–æ–±–∞–≤–∏—Ç—å –ø—É—Å—Ç–æ–π –≤–µ–∫—Ç–æ—Ä
    }
}
```

## 8. –†–∞–∑–±–∏–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫

### –†–∞–∑–±–∏–µ–Ω–∏–µ –ø–æ –ø—Ä–æ–±–µ–ª–∞–º —Å `getline`
```cpp
#include <sstream>
string line;
getline(cin, line);
stringstream ss(line);
string type, transaction, element;
ss >> type >> transaction >> element;
```

### –†–∞–∑–±–∏–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –Ω–∞ –≤–µ–∫—Ç–æ—Ä —Å–ª–æ–≤
```cpp
istringstream iss(command);
vector<string> realCommand;
string word;
while (iss >> word) {
    realCommand.push_back(word);
}
```

## 9. –•—ç—à-—Ç–∞–±–ª–∏—Ü—ã
- –ï—Å–ª–∏ –∫–ª—é—á —Ç–∏–ø–∞ `int`, –≤—Å—Ç–∞–≤–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –∑–∞ `O(1)`.

## 10. –ü—Ä–∏–º–µ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã `MapNote`
```cpp
struct MapNote {
    int hash;
    string value;
    int count;
};
```

## 11. –û–±—É—á–µ–Ω–∏–µ —Å –ø–æ–¥–∫—Ä–µ–ø–ª–µ–Ω–∏–µ–º (Reinforcement Learning)
- **Agent** (–ê–≥–µ–Ω—Ç)
- **Reward Function** (–§—É–Ω–∫—Ü–∏—è –Ω–∞–≥—Ä–∞–¥—ã):
  ```cpp
  double reward(State s, Action a);
  ```
- **Action Policy** (–ü–æ–ª–∏—Ç–∏–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π):
  ```cpp
  Action policy(Observation o);
  ```

## 12. –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ, —Ä–µ—Å—É—Ä—Å–Ω—ã–µ –∏ —ç–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –±—é–¥–∂–µ—Ç—ã
- **–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –±—é–¥–∂–µ—Ç** ‚Üí 500
- **–†–µ—Å—É—Ä—Å–Ω—ã–π –±—é–¥–∂–µ—Ç** ‚Üí 10
- **–≠–∫–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π –±—é–¥–∂–µ—Ç** ‚Üí 50
- **–û–ø—Ü–∏–∏** ‚Üí 4

------------------------

## Aggregation and Composition

### Key Concepts
- **Aggregating object** (owner) - an object that contains another object.
- **Aggregating class** - a class that contains another object.
- **Aggregated object** (subordinate) - an object contained within another object.
- **Aggregated class** - the class of the subordinate object.

### Differences Between Aggregation and Composition
- **Composition** - when one object (1) depends on another (2). Example: `Student` and `Name`, where `Name` depends on `Student`.
- **Aggregation** - when objects can exist independently. Example: `Address` and `Student`, where `Address` does not depend on `Student`.

---

## Java Learning Plan

1. **Java Basics**: variables, operators, primitive types.
2. **Arrays**: one-dimensional and multi-dimensional, `Arrays` class.
3. **OOP Basics**: introduction, principles, packages, var-arg methods, overloading, overriding.
4. **Classes and Interfaces**: `Object`, `Enum`, nested classes, generics, abstract classes.
5. **Exception Handling**: exceptions and their handling.
6. **Working with Strings**: `String`, `StringBuilder`, `StringBuffer`, text blocks.
7. **Collections**: `List`, `Deque`, `Set`, `Map`, `Collections` class.
8. **Functional Programming in Java 8**: lambda expressions, functional interfaces, method references.
9. **Collectors in Java 8**.
10. **Java IO**: working with console, `Scanner`, `Formatter`, input/output streams.
11. **File I/O**: reading/writing files, streams.

üîó [Full Java roadmap](https://github.com/borymskyi/roadmap-java-sng?tab=readme-ov-file#java-core)

---

# 18.03.2025
## Java Editions
1. **Java SE (Standard Edition)** - standard desktop applications.
2. **Java EE (Enterprise Edition)** - enterprise applications.
3. **Java ME (Micro Edition)** - mobile applications.

### Core Java Components
- **javac** - compiler (translates source code into bytecode).
- **JVM (Java Virtual Machine)** - executes bytecode.
- **JRE (Java Runtime Environment)** - JVM + libraries.
- **JDK (Java Development Kit)** - JRE + development tools.
- **IDE (Integrated Development Environment)**: Eclipse, IntelliJ IDEA, NetBeans.

Execution process:
```plaintext
Text (Hello, World!) -> Source Code (HelloWorld.java) -> Bytecode (HelloWorld.class) -> Machine Code (HelloWorld.exe)
```

---

## Lesson 4: Classes and Objects
### Example Code:
```java
public class Practice {
    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = car1; // Two references to the same object
        
        System.out.println(car1.color);
        System.out.println(car1.maxSpeed);
        System.out.println("-----------------");
        System.out.println(car2.color);
        System.out.println(car2.maxSpeed);
    }
    static class Car {
        String color = "red";
        int maxSpeed = 100;
    }
}
```

---

# 20.03.2025
## Spring App
### `pom.xml`
```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>1.20.6</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

### `application.properties` Configuration
1. SQL connection.
2. Hibernate query logging.
3. Admin password.

### Spring App Architecture
#### Road 1 (Classic Structure):
1. `model` ‚Üí `UserEntity` (database entity).
2. `dto` ‚Üí `User` (data transfer object).
3. `controller` ‚Üí `UserController` (`@RestController`, API methods).
4. `service` ‚Üí `UserService` (`@Service`, business logic).
5. `repository` ‚Üí `UserRepository` (`JpaRepository<UserEntity, UUID>`).

#### Road 2 (Implementing createUser):
```java
public List<User> getAllUsers() {
    return userRepository.findAll().stream()
        .map(userEntity -> User.builder()
            .uuid(userEntity.getUuid())
            .username(userEntity.getUsername())
            .password(userEntity.getPassword())
            .name(userEntity.getName())
            .surname(userEntity.getSurname())
            .balance(userEntity.getBalance())
            .userRole(userEntity.getUserRole())
            .createdAt(userEntity.getCreatedAt())
            .build())
        .toList();
}
```

Additional:
- `application.properties`: `spring.jpa.hibernate.ddl-auto=update` (automatic table creation).
- `compose.yml`: `ports` (database connection).
- `scripts/init.sql`: database initialization.

---

# 21.03.2025
## Codewars: BattleShip Task (Maps)
### Useful `Map` Methods:
```java
Map<String, Integer> map = new HashMap<>(); // Stored in heap
Map<String, Integer> map = new LinkedHashMap<>(); // Maintains order
Map<String, Integer> map = new TreeMap<>(); // Sorted

map.put("Alice", 1);
map.put("Bob", 2);
map.put("Charlie", 3);

map.get("Alice"); // 1
map.containsKey("Alice"); // true
map.remove("Alice"); // remove
map.keySet(); // all keys
map.values(); // all values
map.getOrDefault("Alice", 0); // 1
```

### Using `Set`
```java
Set<String> set = new HashSet<>(); // Stored in heap
Set<String> set = new LinkedHashSet<>(); // Maintains order
Set<String> set = new TreeSet<>(); // Sorted
```